# Walleca 詳細設計書

## 1. システムアーキテクチャ

### 1.1 全体構成図

```
┌─────────────────────────────────────────────────────────────────┐
│                         Client Layer                            │
├─────────────────────┬─────────────────────┬────────────────────┤
│   React Web App     │   Flutter iOS App   │  Flutter Android   │
│   (TypeScript)      │                     │       App          │
└─────────┬───────────┴─────────┬───────────┴──────────┬─────────┘
          │                     │                      │
          └─────────────────────┼──────────────────────┘
                                │ HTTPS (REST API)
                                ▼
┌─────────────────────────────────────────────────────────────────┐
│                     API Gateway (Nginx)                         │
│                   - SSL Termination                             │
│                   - Rate Limiting                               │
│                   - Static File Serving                         │
└─────────────────────────────┬───────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                   Application Layer                             │
│  ┌────────────────────────────────────────────────────────┐    │
│  │           Node.js API Server (Express + TypeScript)     │    │
│  │  ┌─────────┐ ┌──────────┐ ┌──────────┐ ┌───────────┐  │    │
│  │  │  Auth   │ │ Receipt  │ │Transaction│ │Subscription│  │    │
│  │  │ Module  │ │  Module  │ │  Module  │ │  Module   │  │    │
│  │  └─────────┘ └──────────┘ └──────────┘ └───────────┘  │    │
│  └────────────────────────────────────────────────────────┘    │
└──────────┬──────────────────┬───────────────────┬──────────────┘
           │                  │                   │
           ▼                  ▼                   ▼
┌──────────────────┐ ┌────────────────┐ ┌────────────────────────┐
│   PostgreSQL     │ │     Redis      │ │   Local Storage        │
│   (Primary DB)   │ │ (Cache/Queue)  │ │   (Images)             │
└──────────────────┘ └───────┬────────┘ └────────────────────────┘
                             │
                             ▼
                    ┌────────────────┐
                    │  OCR Worker    │
                    │  (Tesseract)   │
                    └────────────────┘
```

### 1.2 技術スタック詳細

| レイヤー | 技術 | バージョン |
|---------|------|-----------|
| Web Frontend | React 18 + TypeScript | 18.2.x |
| State Management | Zustand | 4.x |
| UI Framework | Tailwind CSS + shadcn/ui | 3.x |
| HTTP Client | Axios | 1.x |
| Mobile | Flutter | 3.x |
| API Server | Node.js + Express | Node 20 LTS |
| ORM | Prisma | 5.x |
| Database | PostgreSQL | 16.x |
| Cache/Queue | Redis | 7.x |
| OCR Engine | Tesseract | 5.x |
| Container | Docker + Docker Compose | 24.x |
| Reverse Proxy | Nginx | 1.25.x |

---

## 2. データベース設計

### 2.1 ER図

```
┌──────────────────┐       ┌──────────────────────┐
│      users       │       │      receipts        │
├──────────────────┤       ├──────────────────────┤
│ id (PK)          │───┐   │ id (PK)              │
│ email            │   │   │ user_id (FK)         │◄──┐
│ password_hash    │   │   │ image_path           │   │
│ display_name     │   │   │ ocr_status           │   │
│ created_at       │   │   │ ocr_raw_text         │   │
│ updated_at       │   │   │ extracted_merchant   │   │
└──────────────────┘   │   │ extracted_date       │   │
                       │   │ extracted_total      │   │
                       │   │ created_at           │   │
                       │   │ updated_at           │   │
                       │   └──────────────────────┘   │
                       │                              │
                       │   ┌──────────────────────┐   │
                       │   │    transactions      │   │
                       │   ├──────────────────────┤   │
                       └──►│ id (PK)              │   │
                           │ user_id (FK)         │   │
                           │ receipt_id (FK)      │───┘
                           │ type                 │
                           │ amount               │
                           │ transaction_date     │
                           │ merchant             │
                           │ properties (JSONB)   │
                           │ created_at           │
                           │ updated_at           │
                           └──────────────────────┘

┌──────────────────────┐   ┌──────────────────────┐
│   subscriptions      │   │       views          │
├──────────────────────┤   ├──────────────────────┤
│ id (PK)              │   │ id (PK)              │
│ user_id (FK)         │   │ user_id (FK)         │
│ service_name         │   │ name                 │
│ amount               │   │ view_type            │
│ billing_cycle        │   │ filters (JSONB)      │
│ next_payment_date    │   │ sort_config (JSONB)  │
│ category             │   │ group_by             │
│ status               │   │ created_at           │
│ created_at           │   │ updated_at           │
│ updated_at           │   └──────────────────────┘
└──────────────────────┘

┌──────────────────────┐
│    notifications     │
├──────────────────────┤
│ id (PK)              │
│ user_id (FK)         │
│ type                 │
│ title                │
│ message              │
│ is_read              │
│ scheduled_at         │
│ created_at           │
└──────────────────────┘
```

### 2.2 テーブル定義

#### 2.2.1 users（ユーザー）

```sql
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    email VARCHAR(255) NOT NULL UNIQUE,
    password_hash VARCHAR(255) NOT NULL,
    display_name VARCHAR(100) NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_users_email ON users(email);
```

#### 2.2.2 receipts（レシート）

```sql
CREATE TYPE ocr_status AS ENUM ('pending', 'processing', 'success', 'failed');

CREATE TABLE receipts (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    image_path VARCHAR(500) NOT NULL,
    image_size INTEGER NOT NULL,
    mime_type VARCHAR(50) NOT NULL,
    ocr_status ocr_status DEFAULT 'pending',
    ocr_raw_text TEXT,
    extracted_merchant VARCHAR(255),
    extracted_date DATE,
    extracted_total DECIMAL(12, 2),
    ocr_processed_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_receipts_user_id ON receipts(user_id);
CREATE INDEX idx_receipts_ocr_status ON receipts(ocr_status);
CREATE INDEX idx_receipts_created_at ON receipts(created_at);
```

#### 2.2.3 transactions（取引）

```sql
CREATE TYPE transaction_type AS ENUM ('expense', 'income', 'adjustment');

CREATE TABLE transactions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    receipt_id UUID REFERENCES receipts(id) ON DELETE SET NULL,
    type transaction_type NOT NULL DEFAULT 'expense',
    amount DECIMAL(12, 2) NOT NULL,
    transaction_date DATE NOT NULL,
    merchant VARCHAR(255),
    properties JSONB DEFAULT '{}',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- propertiesの構造例
-- {
--   "category": "食費",
--   "tags": ["外食", "ランチ"],
--   "payment_method": "クレジットカード",
--   "memo": "同僚とのランチ"
-- }

CREATE INDEX idx_transactions_user_id ON transactions(user_id);
CREATE INDEX idx_transactions_date ON transactions(transaction_date);
CREATE INDEX idx_transactions_type ON transactions(type);
CREATE INDEX idx_transactions_properties ON transactions USING GIN(properties);
```

#### 2.2.4 subscriptions（サブスクリプション）

```sql
CREATE TYPE billing_cycle AS ENUM ('monthly', 'yearly');
CREATE TYPE subscription_status AS ENUM ('active', 'paused', 'cancelled');

CREATE TABLE subscriptions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    service_name VARCHAR(255) NOT NULL,
    amount DECIMAL(12, 2) NOT NULL,
    billing_cycle billing_cycle NOT NULL DEFAULT 'monthly',
    next_payment_date DATE NOT NULL,
    category VARCHAR(100),
    status subscription_status DEFAULT 'active',
    memo TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_subscriptions_user_id ON subscriptions(user_id);
CREATE INDEX idx_subscriptions_status ON subscriptions(status);
CREATE INDEX idx_subscriptions_next_payment ON subscriptions(next_payment_date);
```

#### 2.2.5 views（ビュー設定）

```sql
CREATE TYPE view_type AS ENUM ('list', 'calendar');

CREATE TABLE views (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    name VARCHAR(100) NOT NULL,
    view_type view_type NOT NULL DEFAULT 'list',
    filters JSONB DEFAULT '{}',
    sort_config JSONB DEFAULT '{"field": "transaction_date", "order": "desc"}',
    group_by VARCHAR(50),
    is_default BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- filtersの構造例
-- {
--   "date_range": {"start": "2024-01-01", "end": "2024-12-31"},
--   "categories": ["食費", "交通費"],
--   "tags": ["外食"],
--   "type": "expense",
--   "amount_min": 0,
--   "amount_max": 10000
-- }

CREATE INDEX idx_views_user_id ON views(user_id);
```

#### 2.2.6 notifications（通知）

```sql
CREATE TYPE notification_type AS ENUM ('subscription_reminder', 'system', 'info');

CREATE TABLE notifications (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    type notification_type NOT NULL,
    title VARCHAR(255) NOT NULL,
    message TEXT,
    related_id UUID,
    is_read BOOLEAN DEFAULT FALSE,
    scheduled_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_notifications_user_id ON notifications(user_id);
CREATE INDEX idx_notifications_is_read ON notifications(is_read);
CREATE INDEX idx_notifications_scheduled ON notifications(scheduled_at);
```

#### 2.2.7 refresh_tokens（リフレッシュトークン）

```sql
CREATE TABLE refresh_tokens (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    token_hash VARCHAR(255) NOT NULL UNIQUE,
    device_info VARCHAR(255),
    expires_at TIMESTAMP WITH TIME ZONE NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_refresh_tokens_user_id ON refresh_tokens(user_id);
CREATE INDEX idx_refresh_tokens_expires ON refresh_tokens(expires_at);
```

---

## 3. API設計

### 3.1 共通仕様

#### ベースURL
```
https://api.walleca.local/v1
```

#### 認証
- Bearer Token（JWT）を使用
- Access Token: 有効期限 15分
- Refresh Token: 有効期限 30日

#### リクエストヘッダー
```
Authorization: Bearer <access_token>
Content-Type: application/json
```

#### レスポンス形式
```typescript
// 成功時
{
  "success": true,
  "data": T,
  "meta"?: {
    "page": number,
    "limit": number,
    "total": number,
    "totalPages": number
  }
}

// エラー時
{
  "success": false,
  "error": {
    "code": string,
    "message": string,
    "details"?: any
  }
}
```

#### エラーコード一覧
| コード | HTTPステータス | 説明 |
|--------|---------------|------|
| AUTH_INVALID_CREDENTIALS | 401 | 認証情報が無効 |
| AUTH_TOKEN_EXPIRED | 401 | トークン期限切れ |
| AUTH_UNAUTHORIZED | 403 | 権限なし |
| RESOURCE_NOT_FOUND | 404 | リソースが見つからない |
| VALIDATION_ERROR | 400 | バリデーションエラー |
| FILE_TOO_LARGE | 400 | ファイルサイズ超過 |
| INTERNAL_ERROR | 500 | サーバー内部エラー |

---

### 3.2 認証API

#### POST /auth/register - ユーザー登録
```typescript
// Request
{
  "email": "user@example.com",
  "password": "securePassword123",
  "displayName": "山田太郎"
}

// Response 201
{
  "success": true,
  "data": {
    "user": {
      "id": "uuid",
      "email": "user@example.com",
      "displayName": "山田太郎",
      "createdAt": "2024-01-01T00:00:00Z"
    },
    "accessToken": "eyJhbG...",
    "refreshToken": "eyJhbG..."
  }
}
```

#### POST /auth/login - ログイン
```typescript
// Request
{
  "email": "user@example.com",
  "password": "securePassword123"
}

// Response 200
{
  "success": true,
  "data": {
    "user": {
      "id": "uuid",
      "email": "user@example.com",
      "displayName": "山田太郎"
    },
    "accessToken": "eyJhbG...",
    "refreshToken": "eyJhbG..."
  }
}
```

#### POST /auth/refresh - トークン更新
```typescript
// Request
{
  "refreshToken": "eyJhbG..."
}

// Response 200
{
  "success": true,
  "data": {
    "accessToken": "eyJhbG...",
    "refreshToken": "eyJhbG..."
  }
}
```

#### POST /auth/logout - ログアウト
```typescript
// Request
{
  "refreshToken": "eyJhbG..."
}

// Response 200
{
  "success": true,
  "data": {
    "message": "ログアウトしました"
  }
}
```

#### GET /auth/me - 現在のユーザー情報
```typescript
// Response 200
{
  "success": true,
  "data": {
    "id": "uuid",
    "email": "user@example.com",
    "displayName": "山田太郎",
    "createdAt": "2024-01-01T00:00:00Z"
  }
}
```

---

### 3.3 レシートAPI

#### POST /receipts - レシートアップロード
```typescript
// Request (multipart/form-data)
// - image: File (JPEG/PNG, max 10MB)

// Response 201
{
  "success": true,
  "data": {
    "id": "uuid",
    "imagePath": "/uploads/receipts/2024/01/uuid.jpg",
    "ocrStatus": "pending",
    "createdAt": "2024-01-01T00:00:00Z"
  }
}
```

#### GET /receipts - レシート一覧取得
```typescript
// Query Parameters
// - page: number (default: 1)
// - limit: number (default: 20, max: 100)
// - status: 'pending' | 'processing' | 'success' | 'failed'
// - startDate: string (ISO date)
// - endDate: string (ISO date)

// Response 200
{
  "success": true,
  "data": [
    {
      "id": "uuid",
      "imagePath": "/uploads/receipts/2024/01/uuid.jpg",
      "ocrStatus": "success",
      "extractedMerchant": "コンビニA",
      "extractedDate": "2024-01-15",
      "extractedTotal": 1500,
      "createdAt": "2024-01-15T10:30:00Z"
    }
  ],
  "meta": {
    "page": 1,
    "limit": 20,
    "total": 45,
    "totalPages": 3
  }
}
```

#### GET /receipts/:id - レシート詳細取得
```typescript
// Response 200
{
  "success": true,
  "data": {
    "id": "uuid",
    "imagePath": "/uploads/receipts/2024/01/uuid.jpg",
    "imageSize": 245000,
    "mimeType": "image/jpeg",
    "ocrStatus": "success",
    "ocrRawText": "コンビニA\n東京都...\n合計 ¥1,500",
    "extractedMerchant": "コンビニA",
    "extractedDate": "2024-01-15",
    "extractedTotal": 1500,
    "ocrProcessedAt": "2024-01-15T10:31:00Z",
    "transaction": {
      "id": "uuid",
      "amount": 1500,
      "transactionDate": "2024-01-15"
    },
    "createdAt": "2024-01-15T10:30:00Z"
  }
}
```

#### PATCH /receipts/:id - レシート情報更新（OCR結果修正）
```typescript
// Request
{
  "extractedMerchant": "コンビニA 渋谷店",
  "extractedDate": "2024-01-15",
  "extractedTotal": 1580
}

// Response 200
{
  "success": true,
  "data": {
    "id": "uuid",
    "extractedMerchant": "コンビニA 渋谷店",
    "extractedDate": "2024-01-15",
    "extractedTotal": 1580,
    "updatedAt": "2024-01-15T11:00:00Z"
  }
}
```

#### POST /receipts/:id/retry-ocr - OCR再実行
```typescript
// Response 200
{
  "success": true,
  "data": {
    "id": "uuid",
    "ocrStatus": "pending",
    "message": "OCR処理をキューに追加しました"
  }
}
```

#### DELETE /receipts/:id - レシート削除
```typescript
// Response 200
{
  "success": true,
  "data": {
    "message": "レシートを削除しました"
  }
}
```

#### POST /receipts/:id/confirm - レシート確定（Transaction生成）
```typescript
// Request
{
  "merchant": "コンビニA 渋谷店",
  "amount": 1580,
  "transactionDate": "2024-01-15",
  "type": "expense",
  "properties": {
    "category": "食費",
    "tags": ["コンビニ"],
    "paymentMethod": "現金"
  }
}

// Response 201
{
  "success": true,
  "data": {
    "receipt": {
      "id": "uuid",
      "ocrStatus": "success"
    },
    "transaction": {
      "id": "uuid",
      "amount": 1580,
      "transactionDate": "2024-01-15",
      "merchant": "コンビニA 渋谷店",
      "type": "expense",
      "properties": {
        "category": "食費",
        "tags": ["コンビニ"],
        "paymentMethod": "現金"
      }
    }
  }
}
```

---

### 3.4 取引（Transaction）API

#### GET /transactions - 取引一覧取得
```typescript
// Query Parameters
// - page: number (default: 1)
// - limit: number (default: 20, max: 100)
// - type: 'expense' | 'income' | 'adjustment'
// - startDate: string (ISO date)
// - endDate: string (ISO date)
// - category: string
// - tags: string (comma-separated)
// - merchant: string (部分一致)
// - minAmount: number
// - maxAmount: number
// - sortBy: 'date' | 'amount' (default: 'date')
// - sortOrder: 'asc' | 'desc' (default: 'desc')

// Response 200
{
  "success": true,
  "data": [
    {
      "id": "uuid",
      "type": "expense",
      "amount": 1580,
      "transactionDate": "2024-01-15",
      "merchant": "コンビニA 渋谷店",
      "properties": {
        "category": "食費",
        "tags": ["コンビニ"],
        "paymentMethod": "現金"
      },
      "receipt": {
        "id": "uuid",
        "imagePath": "/uploads/receipts/2024/01/uuid.jpg"
      },
      "createdAt": "2024-01-15T10:30:00Z"
    }
  ],
  "meta": {
    "page": 1,
    "limit": 20,
    "total": 150,
    "totalPages": 8
  }
}
```

#### POST /transactions - 取引登録（手動）
```typescript
// Request
{
  "type": "expense",
  "amount": 3000,
  "transactionDate": "2024-01-20",
  "merchant": "レストランB",
  "properties": {
    "category": "食費",
    "tags": ["外食", "ディナー"],
    "paymentMethod": "クレジットカード",
    "memo": "誕生日ディナー"
  }
}

// Response 201
{
  "success": true,
  "data": {
    "id": "uuid",
    "type": "expense",
    "amount": 3000,
    "transactionDate": "2024-01-20",
    "merchant": "レストランB",
    "properties": {
      "category": "食費",
      "tags": ["外食", "ディナー"],
      "paymentMethod": "クレジットカード",
      "memo": "誕生日ディナー"
    },
    "createdAt": "2024-01-20T19:00:00Z"
  }
}
```

#### GET /transactions/:id - 取引詳細取得
```typescript
// Response 200
{
  "success": true,
  "data": {
    "id": "uuid",
    "type": "expense",
    "amount": 1580,
    "transactionDate": "2024-01-15",
    "merchant": "コンビニA 渋谷店",
    "properties": {
      "category": "食費",
      "tags": ["コンビニ"],
      "paymentMethod": "現金"
    },
    "receipt": {
      "id": "uuid",
      "imagePath": "/uploads/receipts/2024/01/uuid.jpg",
      "ocrRawText": "..."
    },
    "createdAt": "2024-01-15T10:30:00Z",
    "updatedAt": "2024-01-15T10:30:00Z"
  }
}
```

#### PATCH /transactions/:id - 取引更新
```typescript
// Request (partial update)
{
  "amount": 1600,
  "properties": {
    "category": "日用品",
    "memo": "修正しました"
  }
}

// Response 200
{
  "success": true,
  "data": {
    "id": "uuid",
    "amount": 1600,
    "properties": {
      "category": "日用品",
      "tags": ["コンビニ"],
      "paymentMethod": "現金",
      "memo": "修正しました"
    },
    "updatedAt": "2024-01-16T10:00:00Z"
  }
}
```

#### DELETE /transactions/:id - 取引削除
```typescript
// Response 200
{
  "success": true,
  "data": {
    "message": "取引を削除しました"
  }
}
```

#### GET /transactions/summary - 集計取得
```typescript
// Query Parameters
// - startDate: string (required)
// - endDate: string (required)
// - groupBy: 'day' | 'week' | 'month' | 'category' | 'paymentMethod'

// Response 200
{
  "success": true,
  "data": {
    "period": {
      "start": "2024-01-01",
      "end": "2024-01-31"
    },
    "totals": {
      "expense": 150000,
      "income": 300000,
      "balance": 150000
    },
    "groups": [
      {
        "key": "食費",
        "expense": 45000,
        "income": 0,
        "count": 32
      },
      {
        "key": "交通費",
        "expense": 15000,
        "income": 0,
        "count": 20
      }
    ]
  }
}
```

---

### 3.5 サブスクリプションAPI

#### GET /subscriptions - サブスク一覧取得
```typescript
// Query Parameters
// - status: 'active' | 'paused' | 'cancelled'
// - category: string

// Response 200
{
  "success": true,
  "data": [
    {
      "id": "uuid",
      "serviceName": "Netflix",
      "amount": 1490,
      "billingCycle": "monthly",
      "nextPaymentDate": "2024-02-15",
      "category": "動画配信",
      "status": "active",
      "createdAt": "2024-01-01T00:00:00Z"
    }
  ]
}
```

#### POST /subscriptions - サブスク登録
```typescript
// Request
{
  "serviceName": "Spotify",
  "amount": 980,
  "billingCycle": "monthly",
  "nextPaymentDate": "2024-02-01",
  "category": "音楽配信",
  "memo": "ファミリープラン"
}

// Response 201
{
  "success": true,
  "data": {
    "id": "uuid",
    "serviceName": "Spotify",
    "amount": 980,
    "billingCycle": "monthly",
    "nextPaymentDate": "2024-02-01",
    "category": "音楽配信",
    "status": "active",
    "memo": "ファミリープラン",
    "createdAt": "2024-01-15T10:00:00Z"
  }
}
```

#### GET /subscriptions/:id - サブスク詳細取得
```typescript
// Response 200
{
  "success": true,
  "data": {
    "id": "uuid",
    "serviceName": "Netflix",
    "amount": 1490,
    "billingCycle": "monthly",
    "nextPaymentDate": "2024-02-15",
    "category": "動画配信",
    "status": "active",
    "memo": "スタンダードプラン",
    "createdAt": "2024-01-01T00:00:00Z",
    "updatedAt": "2024-01-01T00:00:00Z"
  }
}
```

#### PATCH /subscriptions/:id - サブスク更新
```typescript
// Request
{
  "amount": 1980,
  "status": "active",
  "memo": "プレミアムプランに変更"
}

// Response 200
{
  "success": true,
  "data": {
    "id": "uuid",
    "serviceName": "Netflix",
    "amount": 1980,
    "status": "active",
    "memo": "プレミアムプランに変更",
    "updatedAt": "2024-01-20T10:00:00Z"
  }
}
```

#### DELETE /subscriptions/:id - サブスク削除
```typescript
// Response 200
{
  "success": true,
  "data": {
    "message": "サブスクリプションを削除しました"
  }
}
```

#### GET /subscriptions/summary - サブスク集計
```typescript
// Response 200
{
  "success": true,
  "data": {
    "monthlyTotal": 5950,
    "yearlyTotal": 71400,
    "activeCount": 5,
    "byCategory": [
      {
        "category": "動画配信",
        "monthlyTotal": 2470,
        "count": 2
      },
      {
        "category": "音楽配信",
        "monthlyTotal": 980,
        "count": 1
      }
    ],
    "upcomingPayments": [
      {
        "id": "uuid",
        "serviceName": "Spotify",
        "amount": 980,
        "nextPaymentDate": "2024-02-01",
        "daysUntil": 3
      }
    ]
  }
}
```

---

### 3.6 ビューAPI

#### GET /views - ビュー一覧取得
```typescript
// Response 200
{
  "success": true,
  "data": [
    {
      "id": "uuid",
      "name": "今月の支出",
      "viewType": "list",
      "filters": {
        "dateRange": {
          "start": "2024-01-01",
          "end": "2024-01-31"
        },
        "type": "expense"
      },
      "sortConfig": {
        "field": "transaction_date",
        "order": "desc"
      },
      "groupBy": "category",
      "isDefault": true
    }
  ]
}
```

#### POST /views - ビュー作成
```typescript
// Request
{
  "name": "食費カレンダー",
  "viewType": "calendar",
  "filters": {
    "categories": ["食費"]
  },
  "sortConfig": {
    "field": "transaction_date",
    "order": "asc"
  }
}

// Response 201
{
  "success": true,
  "data": {
    "id": "uuid",
    "name": "食費カレンダー",
    "viewType": "calendar",
    "filters": {
      "categories": ["食費"]
    },
    "sortConfig": {
      "field": "transaction_date",
      "order": "asc"
    },
    "createdAt": "2024-01-15T10:00:00Z"
  }
}
```

#### GET /views/:id - ビュー詳細取得
```typescript
// Response 200
{
  "success": true,
  "data": {
    "id": "uuid",
    "name": "今月の支出",
    "viewType": "list",
    "filters": {...},
    "sortConfig": {...},
    "groupBy": "category",
    "isDefault": true,
    "createdAt": "2024-01-01T00:00:00Z",
    "updatedAt": "2024-01-15T10:00:00Z"
  }
}
```

#### GET /views/:id/data - ビューに基づくデータ取得
```typescript
// Query Parameters
// - page: number
// - limit: number

// Response 200
{
  "success": true,
  "data": {
    "view": {
      "id": "uuid",
      "name": "今月の支出",
      "viewType": "list"
    },
    "transactions": [...],
    "groups": [
      {
        "key": "食費",
        "transactions": [...],
        "subtotal": 45000
      }
    ]
  },
  "meta": {
    "page": 1,
    "limit": 20,
    "total": 50
  }
}
```

#### PATCH /views/:id - ビュー更新
```typescript
// Request
{
  "name": "今月の支出（更新）",
  "filters": {
    "dateRange": {
      "start": "2024-02-01",
      "end": "2024-02-29"
    }
  }
}

// Response 200
{
  "success": true,
  "data": {
    "id": "uuid",
    "name": "今月の支出（更新）",
    "updatedAt": "2024-02-01T10:00:00Z"
  }
}
```

#### DELETE /views/:id - ビュー削除
```typescript
// Response 200
{
  "success": true,
  "data": {
    "message": "ビューを削除しました"
  }
}
```

---

### 3.7 通知API

#### GET /notifications - 通知一覧取得
```typescript
// Query Parameters
// - isRead: boolean
// - limit: number (default: 50)

// Response 200
{
  "success": true,
  "data": [
    {
      "id": "uuid",
      "type": "subscription_reminder",
      "title": "支払日が近づいています",
      "message": "Netflixの支払日が3日後です",
      "relatedId": "subscription-uuid",
      "isRead": false,
      "createdAt": "2024-01-12T09:00:00Z"
    }
  ]
}
```

#### PATCH /notifications/:id/read - 既読にする
```typescript
// Response 200
{
  "success": true,
  "data": {
    "id": "uuid",
    "isRead": true
  }
}
```

#### POST /notifications/read-all - 全て既読にする
```typescript
// Response 200
{
  "success": true,
  "data": {
    "updatedCount": 5
  }
}
```

---

### 3.8 エクスポートAPI

#### POST /export/transactions - 取引CSVエクスポート
```typescript
// Request
{
  "startDate": "2024-01-01",
  "endDate": "2024-12-31",
  "type": "expense",
  "format": "csv"
}

// Response 200 (Content-Type: text/csv)
// ファイルダウンロード
```

#### POST /export/subscriptions - サブスクCSVエクスポート
```typescript
// Request
{
  "status": "active",
  "format": "csv"
}

// Response 200 (Content-Type: text/csv)
// ファイルダウンロード
```

---

### 3.9 検索API

#### GET /search - 全文検索
```typescript
// Query Parameters
// - q: string (検索クエリ)
// - type: 'all' | 'transactions' | 'receipts' | 'subscriptions'
// - limit: number (default: 20)

// Response 200
{
  "success": true,
  "data": {
    "transactions": [
      {
        "id": "uuid",
        "merchant": "コンビニA",
        "amount": 1500,
        "matchedField": "merchant",
        "highlight": "<em>コンビニ</em>A"
      }
    ],
    "receipts": [
      {
        "id": "uuid",
        "ocrRawText": "...コンビニ...",
        "matchedField": "ocrRawText"
      }
    ],
    "subscriptions": []
  }
}
```

---

## 4. フロントエンド設計（React Web）

### 4.1 ディレクトリ構成

```
web/
├── public/
│   ├── index.html
│   └── favicon.ico
├── src/
│   ├── main.tsx                    # エントリーポイント
│   ├── App.tsx                     # ルートコンポーネント
│   ├── routes.tsx                  # ルーティング定義
│   │
│   ├── api/                        # API通信層
│   │   ├── client.ts               # Axiosインスタンス
│   │   ├── auth.ts                 # 認証API
│   │   ├── receipts.ts             # レシートAPI
│   │   ├── transactions.ts         # 取引API
│   │   ├── subscriptions.ts        # サブスクAPI
│   │   ├── views.ts                # ビューAPI
│   │   └── notifications.ts        # 通知API
│   │
│   ├── components/                 # UIコンポーネント
│   │   ├── ui/                     # 汎用UIコンポーネント（shadcn/ui）
│   │   │   ├── Button.tsx
│   │   │   ├── Input.tsx
│   │   │   ├── Card.tsx
│   │   │   ├── Dialog.tsx
│   │   │   ├── Table.tsx
│   │   │   ├── Calendar.tsx
│   │   │   └── ...
│   │   │
│   │   ├── layout/                 # レイアウトコンポーネント
│   │   │   ├── Header.tsx
│   │   │   ├── Sidebar.tsx
│   │   │   ├── MainLayout.tsx
│   │   │   └── AuthLayout.tsx
│   │   │
│   │   ├── auth/                   # 認証関連
│   │   │   ├── LoginForm.tsx
│   │   │   ├── RegisterForm.tsx
│   │   │   └── ProtectedRoute.tsx
│   │   │
│   │   ├── receipts/               # レシート関連
│   │   │   ├── ReceiptUploader.tsx
│   │   │   ├── ReceiptList.tsx
│   │   │   ├── ReceiptCard.tsx
│   │   │   ├── ReceiptDetail.tsx
│   │   │   ├── OcrResultEditor.tsx
│   │   │   └── ReceiptConfirmDialog.tsx
│   │   │
│   │   ├── transactions/           # 取引関連
│   │   │   ├── TransactionList.tsx
│   │   │   ├── TransactionCard.tsx
│   │   │   ├── TransactionForm.tsx
│   │   │   ├── TransactionDetail.tsx
│   │   │   ├── TransactionFilters.tsx
│   │   │   └── TransactionSummary.tsx
│   │   │
│   │   ├── subscriptions/          # サブスク関連
│   │   │   ├── SubscriptionList.tsx
│   │   │   ├── SubscriptionCard.tsx
│   │   │   ├── SubscriptionForm.tsx
│   │   │   └── SubscriptionSummary.tsx
│   │   │
│   │   ├── views/                  # ビュー関連
│   │   │   ├── ViewSelector.tsx
│   │   │   ├── ViewEditor.tsx
│   │   │   ├── ListView.tsx
│   │   │   └── CalendarView.tsx
│   │   │
│   │   └── common/                 # 共通コンポーネント
│   │       ├── LoadingSpinner.tsx
│   │       ├── ErrorBoundary.tsx
│   │       ├── EmptyState.tsx
│   │       ├── Pagination.tsx
│   │       └── NotificationBell.tsx
│   │
│   ├── hooks/                      # カスタムフック
│   │   ├── useAuth.ts
│   │   ├── useReceipts.ts
│   │   ├── useTransactions.ts
│   │   ├── useSubscriptions.ts
│   │   ├── useViews.ts
│   │   ├── useNotifications.ts
│   │   └── useDebounce.ts
│   │
│   ├── stores/                     # 状態管理（Zustand）
│   │   ├── authStore.ts
│   │   ├── receiptStore.ts
│   │   ├── transactionStore.ts
│   │   ├── subscriptionStore.ts
│   │   ├── viewStore.ts
│   │   └── notificationStore.ts
│   │
│   ├── pages/                      # ページコンポーネント
│   │   ├── auth/
│   │   │   ├── LoginPage.tsx
│   │   │   └── RegisterPage.tsx
│   │   ├── dashboard/
│   │   │   └── DashboardPage.tsx
│   │   ├── receipts/
│   │   │   ├── ReceiptsPage.tsx
│   │   │   └── ReceiptDetailPage.tsx
│   │   ├── transactions/
│   │   │   ├── TransactionsPage.tsx
│   │   │   └── TransactionDetailPage.tsx
│   │   ├── subscriptions/
│   │   │   └── SubscriptionsPage.tsx
│   │   └── settings/
│   │       └── SettingsPage.tsx
│   │
│   ├── types/                      # TypeScript型定義
│   │   ├── api.ts                  # APIレスポンス型
│   │   ├── auth.ts
│   │   ├── receipt.ts
│   │   ├── transaction.ts
│   │   ├── subscription.ts
│   │   ├── view.ts
│   │   └── notification.ts
│   │
│   ├── utils/                      # ユーティリティ
│   │   ├── format.ts               # フォーマット関数
│   │   ├── validation.ts           # バリデーション
│   │   ├── storage.ts              # ローカルストレージ
│   │   └── constants.ts            # 定数
│   │
│   └── styles/                     # スタイル
│       ├── globals.css
│       └── tailwind.css
│
├── .env.example
├── .env.local
├── package.json
├── tsconfig.json
├── tailwind.config.js
├── vite.config.ts
└── README.md
```

### 4.2 主要コンポーネント設計

#### 4.2.1 状態管理（Zustand Store）

```typescript
// stores/authStore.ts
import { create } from 'zustand';
import { persist } from 'zustand/middleware';

interface User {
  id: string;
  email: string;
  displayName: string;
}

interface AuthState {
  user: User | null;
  accessToken: string | null;
  isAuthenticated: boolean;
  isLoading: boolean;

  // Actions
  setAuth: (user: User, accessToken: string) => void;
  logout: () => void;
  setLoading: (loading: boolean) => void;
}

export const useAuthStore = create<AuthState>()(
  persist(
    (set) => ({
      user: null,
      accessToken: null,
      isAuthenticated: false,
      isLoading: true,

      setAuth: (user, accessToken) => set({
        user,
        accessToken,
        isAuthenticated: true,
        isLoading: false,
      }),

      logout: () => set({
        user: null,
        accessToken: null,
        isAuthenticated: false,
        isLoading: false,
      }),

      setLoading: (isLoading) => set({ isLoading }),
    }),
    {
      name: 'auth-storage',
      partialize: (state) => ({
        accessToken: state.accessToken,
      }),
    }
  )
);
```

```typescript
// stores/transactionStore.ts
import { create } from 'zustand';
import { Transaction, TransactionFilters } from '@/types/transaction';

interface TransactionState {
  transactions: Transaction[];
  filters: TransactionFilters;
  isLoading: boolean;
  error: string | null;
  pagination: {
    page: number;
    limit: number;
    total: number;
  };

  // Actions
  setTransactions: (transactions: Transaction[]) => void;
  addTransaction: (transaction: Transaction) => void;
  updateTransaction: (id: string, data: Partial<Transaction>) => void;
  deleteTransaction: (id: string) => void;
  setFilters: (filters: Partial<TransactionFilters>) => void;
  resetFilters: () => void;
  setLoading: (loading: boolean) => void;
  setError: (error: string | null) => void;
  setPagination: (pagination: Partial<TransactionState['pagination']>) => void;
}

const defaultFilters: TransactionFilters = {
  startDate: null,
  endDate: null,
  type: null,
  category: null,
  tags: [],
  minAmount: null,
  maxAmount: null,
  sortBy: 'date',
  sortOrder: 'desc',
};

export const useTransactionStore = create<TransactionState>((set) => ({
  transactions: [],
  filters: defaultFilters,
  isLoading: false,
  error: null,
  pagination: {
    page: 1,
    limit: 20,
    total: 0,
  },

  setTransactions: (transactions) => set({ transactions }),

  addTransaction: (transaction) => set((state) => ({
    transactions: [transaction, ...state.transactions],
  })),

  updateTransaction: (id, data) => set((state) => ({
    transactions: state.transactions.map((t) =>
      t.id === id ? { ...t, ...data } : t
    ),
  })),

  deleteTransaction: (id) => set((state) => ({
    transactions: state.transactions.filter((t) => t.id !== id),
  })),

  setFilters: (filters) => set((state) => ({
    filters: { ...state.filters, ...filters },
    pagination: { ...state.pagination, page: 1 },
  })),

  resetFilters: () => set({ filters: defaultFilters }),

  setLoading: (isLoading) => set({ isLoading }),

  setError: (error) => set({ error }),

  setPagination: (pagination) => set((state) => ({
    pagination: { ...state.pagination, ...pagination },
  })),
}));
```

#### 4.2.2 API クライアント

```typescript
// api/client.ts
import axios, { AxiosError, InternalAxiosRequestConfig } from 'axios';
import { useAuthStore } from '@/stores/authStore';

const API_BASE_URL = import.meta.env.VITE_API_BASE_URL || 'http://localhost:3000/v1';

export const apiClient = axios.create({
  baseURL: API_BASE_URL,
  timeout: 30000,
  headers: {
    'Content-Type': 'application/json',
  },
});

// Request interceptor
apiClient.interceptors.request.use(
  (config: InternalAxiosRequestConfig) => {
    const { accessToken } = useAuthStore.getState();
    if (accessToken) {
      config.headers.Authorization = `Bearer ${accessToken}`;
    }
    return config;
  },
  (error) => Promise.reject(error)
);

// Response interceptor
apiClient.interceptors.response.use(
  (response) => response,
  async (error: AxiosError) => {
    const originalRequest = error.config;

    if (error.response?.status === 401 && originalRequest) {
      // Token refresh logic
      try {
        const refreshToken = localStorage.getItem('refreshToken');
        if (refreshToken) {
          const response = await axios.post(`${API_BASE_URL}/auth/refresh`, {
            refreshToken,
          });

          const { accessToken, refreshToken: newRefreshToken } = response.data.data;
          useAuthStore.getState().setAuth(
            useAuthStore.getState().user!,
            accessToken
          );
          localStorage.setItem('refreshToken', newRefreshToken);

          originalRequest.headers.Authorization = `Bearer ${accessToken}`;
          return apiClient(originalRequest);
        }
      } catch (refreshError) {
        useAuthStore.getState().logout();
        localStorage.removeItem('refreshToken');
        window.location.href = '/login';
      }
    }

    return Promise.reject(error);
  }
);

export interface ApiResponse<T> {
  success: boolean;
  data: T;
  meta?: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
  };
}

export interface ApiError {
  success: false;
  error: {
    code: string;
    message: string;
    details?: unknown;
  };
}
```

#### 4.2.3 カスタムフック

```typescript
// hooks/useTransactions.ts
import { useCallback } from 'react';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { transactionsApi } from '@/api/transactions';
import { useTransactionStore } from '@/stores/transactionStore';
import { Transaction, CreateTransactionDto, UpdateTransactionDto } from '@/types/transaction';

export function useTransactions() {
  const queryClient = useQueryClient();
  const { filters, pagination, setTransactions, setPagination } = useTransactionStore();

  const transactionsQuery = useQuery({
    queryKey: ['transactions', filters, pagination.page],
    queryFn: () => transactionsApi.getAll({
      ...filters,
      page: pagination.page,
      limit: pagination.limit,
    }),
    onSuccess: (data) => {
      setTransactions(data.data);
      setPagination({ total: data.meta?.total || 0 });
    },
  });

  const createMutation = useMutation({
    mutationFn: (dto: CreateTransactionDto) => transactionsApi.create(dto),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['transactions'] });
    },
  });

  const updateMutation = useMutation({
    mutationFn: ({ id, dto }: { id: string; dto: UpdateTransactionDto }) =>
      transactionsApi.update(id, dto),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['transactions'] });
    },
  });

  const deleteMutation = useMutation({
    mutationFn: (id: string) => transactionsApi.delete(id),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['transactions'] });
    },
  });

  return {
    transactions: transactionsQuery.data?.data || [],
    isLoading: transactionsQuery.isLoading,
    error: transactionsQuery.error,

    createTransaction: createMutation.mutateAsync,
    updateTransaction: updateMutation.mutateAsync,
    deleteTransaction: deleteMutation.mutateAsync,

    isCreating: createMutation.isPending,
    isUpdating: updateMutation.isPending,
    isDeleting: deleteMutation.isPending,
  };
}
```

#### 4.2.4 ページコンポーネント例

```typescript
// pages/transactions/TransactionsPage.tsx
import { useState } from 'react';
import { MainLayout } from '@/components/layout/MainLayout';
import { TransactionList } from '@/components/transactions/TransactionList';
import { TransactionFilters } from '@/components/transactions/TransactionFilters';
import { TransactionForm } from '@/components/transactions/TransactionForm';
import { TransactionSummary } from '@/components/transactions/TransactionSummary';
import { ViewSelector } from '@/components/views/ViewSelector';
import { Button } from '@/components/ui/Button';
import { Dialog } from '@/components/ui/Dialog';
import { useTransactions } from '@/hooks/useTransactions';
import { useViews } from '@/hooks/useViews';
import { PlusIcon } from 'lucide-react';

export function TransactionsPage() {
  const [isFormOpen, setIsFormOpen] = useState(false);
  const { transactions, isLoading, createTransaction, isCreating } = useTransactions();
  const { currentView, views, setCurrentView } = useViews();

  const handleCreateTransaction = async (data: CreateTransactionDto) => {
    await createTransaction(data);
    setIsFormOpen(false);
  };

  return (
    <MainLayout>
      <div className="space-y-6">
        {/* Header */}
        <div className="flex items-center justify-between">
          <h1 className="text-2xl font-bold">取引一覧</h1>
          <Button onClick={() => setIsFormOpen(true)}>
            <PlusIcon className="w-4 h-4 mr-2" />
            新規取引
          </Button>
        </div>

        {/* Summary */}
        <TransactionSummary />

        {/* View Selector & Filters */}
        <div className="flex items-center gap-4">
          <ViewSelector
            views={views}
            currentView={currentView}
            onSelect={setCurrentView}
          />
          <TransactionFilters />
        </div>

        {/* Transaction List */}
        <TransactionList
          transactions={transactions}
          isLoading={isLoading}
          viewType={currentView?.viewType || 'list'}
        />

        {/* Create Dialog */}
        <Dialog open={isFormOpen} onOpenChange={setIsFormOpen}>
          <Dialog.Content>
            <Dialog.Header>
              <Dialog.Title>新規取引登録</Dialog.Title>
            </Dialog.Header>
            <TransactionForm
              onSubmit={handleCreateTransaction}
              isLoading={isCreating}
              onCancel={() => setIsFormOpen(false)}
            />
          </Dialog.Content>
        </Dialog>
      </div>
    </MainLayout>
  );
}
```

### 4.3 画面遷移図

```
┌─────────────────────────────────────────────────────────────────┐
│                        認証フロー                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   ┌──────────┐     ┌──────────┐     ┌──────────────────┐       │
│   │ ログイン │ ──► │ 新規登録 │ ──► │ ダッシュボード    │       │
│   │   画面   │ ◄── │   画面   │     │                  │       │
│   └──────────┘     └──────────┘     └──────────────────┘       │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                        メインフロー                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   ┌──────────────────────────────────────────────────────┐     │
│   │                   サイドバー                          │     │
│   │  ┌─────────────┐                                     │     │
│   │  │ダッシュボード├───────────────────────────────────►│     │
│   │  └─────────────┘                                     │     │
│   │  ┌─────────────┐     ┌─────────────┐                │     │
│   │  │  レシート   ├────►│レシート詳細 │                │     │
│   │  └─────────────┘     └──────┬──────┘                │     │
│   │                              │ 確定                  │     │
│   │  ┌─────────────┐     ┌──────▼──────┐                │     │
│   │  │   取引一覧  │◄────┤ 取引詳細    │                │     │
│   │  └─────────────┘     └─────────────┘                │     │
│   │  ┌─────────────┐                                     │     │
│   │  │ サブスク    ├───────────────────────────────────►│     │
│   │  └─────────────┘                                     │     │
│   │  ┌─────────────┐                                     │     │
│   │  │   設定      ├───────────────────────────────────►│     │
│   │  └─────────────┘                                     │     │
│   └──────────────────────────────────────────────────────┘     │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 5. バックエンド設計（Node.js API）

### 5.1 ディレクトリ構成

```
api/
├── src/
│   ├── index.ts                    # エントリーポイント
│   ├── app.ts                      # Expressアプリ設定
│   │
│   ├── config/                     # 設定
│   │   ├── index.ts                # 設定読み込み
│   │   ├── database.ts             # DB設定
│   │   ├── redis.ts                # Redis設定
│   │   └── storage.ts              # ストレージ設定
│   │
│   ├── routes/                     # ルーティング
│   │   ├── index.ts                # ルート集約
│   │   ├── auth.routes.ts
│   │   ├── receipts.routes.ts
│   │   ├── transactions.routes.ts
│   │   ├── subscriptions.routes.ts
│   │   ├── views.routes.ts
│   │   ├── notifications.routes.ts
│   │   ├── search.routes.ts
│   │   └── export.routes.ts
│   │
│   ├── controllers/                # コントローラー
│   │   ├── auth.controller.ts
│   │   ├── receipts.controller.ts
│   │   ├── transactions.controller.ts
│   │   ├── subscriptions.controller.ts
│   │   ├── views.controller.ts
│   │   ├── notifications.controller.ts
│   │   ├── search.controller.ts
│   │   └── export.controller.ts
│   │
│   ├── services/                   # ビジネスロジック
│   │   ├── auth.service.ts
│   │   ├── receipts.service.ts
│   │   ├── transactions.service.ts
│   │   ├── subscriptions.service.ts
│   │   ├── views.service.ts
│   │   ├── notifications.service.ts
│   │   ├── ocr.service.ts
│   │   ├── search.service.ts
│   │   └── export.service.ts
│   │
│   ├── repositories/               # データアクセス層
│   │   ├── user.repository.ts
│   │   ├── receipt.repository.ts
│   │   ├── transaction.repository.ts
│   │   ├── subscription.repository.ts
│   │   ├── view.repository.ts
│   │   └── notification.repository.ts
│   │
│   ├── middleware/                 # ミドルウェア
│   │   ├── auth.middleware.ts      # 認証
│   │   ├── validation.middleware.ts # バリデーション
│   │   ├── error.middleware.ts     # エラーハンドリング
│   │   ├── upload.middleware.ts    # ファイルアップロード
│   │   └── rateLimit.middleware.ts # レート制限
│   │
│   ├── validators/                 # 入力バリデーション
│   │   ├── auth.validator.ts
│   │   ├── receipt.validator.ts
│   │   ├── transaction.validator.ts
│   │   ├── subscription.validator.ts
│   │   └── view.validator.ts
│   │
│   ├── workers/                    # バックグラウンドワーカー
│   │   ├── ocr.worker.ts           # OCR処理ワーカー
│   │   └── notification.worker.ts  # 通知スケジューラー
│   │
│   ├── queues/                     # ジョブキュー
│   │   ├── index.ts
│   │   ├── ocr.queue.ts
│   │   └── notification.queue.ts
│   │
│   ├── utils/                      # ユーティリティ
│   │   ├── response.ts             # レスポンスヘルパー
│   │   ├── errors.ts               # カスタムエラー
│   │   ├── logger.ts               # ロガー
│   │   ├── hash.ts                 # ハッシュ関数
│   │   └── jwt.ts                  # JWT関連
│   │
│   └── types/                      # 型定義
│       ├── express.d.ts            # Express拡張型
│       ├── api.ts
│       └── models.ts
│
├── prisma/
│   ├── schema.prisma               # Prismaスキーマ
│   ├── migrations/                 # マイグレーション
│   └── seed.ts                     # シードデータ
│
├── tests/
│   ├── unit/
│   ├── integration/
│   └── e2e/
│
├── .env.example
├── .env
├── package.json
├── tsconfig.json
├── jest.config.js
└── README.md
```

### 5.2 Prismaスキーマ

```prisma
// prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id           String   @id @default(uuid()) @db.Uuid
  email        String   @unique @db.VarChar(255)
  passwordHash String   @map("password_hash") @db.VarChar(255)
  displayName  String   @map("display_name") @db.VarChar(100)
  createdAt    DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt    DateTime @updatedAt @map("updated_at") @db.Timestamptz

  receipts      Receipt[]
  transactions  Transaction[]
  subscriptions Subscription[]
  views         View[]
  notifications Notification[]
  refreshTokens RefreshToken[]

  @@map("users")
}

enum OcrStatus {
  pending
  processing
  success
  failed

  @@map("ocr_status")
}

model Receipt {
  id                String    @id @default(uuid()) @db.Uuid
  userId            String    @map("user_id") @db.Uuid
  imagePath         String    @map("image_path") @db.VarChar(500)
  imageSize         Int       @map("image_size")
  mimeType          String    @map("mime_type") @db.VarChar(50)
  ocrStatus         OcrStatus @default(pending) @map("ocr_status")
  ocrRawText        String?   @map("ocr_raw_text") @db.Text
  extractedMerchant String?   @map("extracted_merchant") @db.VarChar(255)
  extractedDate     DateTime? @map("extracted_date") @db.Date
  extractedTotal    Decimal?  @map("extracted_total") @db.Decimal(12, 2)
  ocrProcessedAt    DateTime? @map("ocr_processed_at") @db.Timestamptz
  createdAt         DateTime  @default(now()) @map("created_at") @db.Timestamptz
  updatedAt         DateTime  @updatedAt @map("updated_at") @db.Timestamptz

  user        User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  transaction Transaction?

  @@index([userId])
  @@index([ocrStatus])
  @@index([createdAt])
  @@map("receipts")
}

enum TransactionType {
  expense
  income
  adjustment

  @@map("transaction_type")
}

model Transaction {
  id              String          @id @default(uuid()) @db.Uuid
  userId          String          @map("user_id") @db.Uuid
  receiptId       String?         @unique @map("receipt_id") @db.Uuid
  type            TransactionType @default(expense)
  amount          Decimal         @db.Decimal(12, 2)
  transactionDate DateTime        @map("transaction_date") @db.Date
  merchant        String?         @db.VarChar(255)
  properties      Json            @default("{}")
  createdAt       DateTime        @default(now()) @map("created_at") @db.Timestamptz
  updatedAt       DateTime        @updatedAt @map("updated_at") @db.Timestamptz

  user    User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  receipt Receipt? @relation(fields: [receiptId], references: [id], onDelete: SetNull)

  @@index([userId])
  @@index([transactionDate])
  @@index([type])
  @@map("transactions")
}

enum BillingCycle {
  monthly
  yearly

  @@map("billing_cycle")
}

enum SubscriptionStatus {
  active
  paused
  cancelled

  @@map("subscription_status")
}

model Subscription {
  id              String             @id @default(uuid()) @db.Uuid
  userId          String             @map("user_id") @db.Uuid
  serviceName     String             @map("service_name") @db.VarChar(255)
  amount          Decimal            @db.Decimal(12, 2)
  billingCycle    BillingCycle       @default(monthly) @map("billing_cycle")
  nextPaymentDate DateTime           @map("next_payment_date") @db.Date
  category        String?            @db.VarChar(100)
  status          SubscriptionStatus @default(active)
  memo            String?            @db.Text
  createdAt       DateTime           @default(now()) @map("created_at") @db.Timestamptz
  updatedAt       DateTime           @updatedAt @map("updated_at") @db.Timestamptz

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([status])
  @@index([nextPaymentDate])
  @@map("subscriptions")
}

enum ViewType {
  list
  calendar

  @@map("view_type")
}

model View {
  id         String   @id @default(uuid()) @db.Uuid
  userId     String   @map("user_id") @db.Uuid
  name       String   @db.VarChar(100)
  viewType   ViewType @default(list) @map("view_type")
  filters    Json     @default("{}")
  sortConfig Json     @default("{\"field\": \"transaction_date\", \"order\": \"desc\"}") @map("sort_config")
  groupBy    String?  @map("group_by") @db.VarChar(50)
  isDefault  Boolean  @default(false) @map("is_default")
  createdAt  DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt  DateTime @updatedAt @map("updated_at") @db.Timestamptz

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("views")
}

enum NotificationType {
  subscription_reminder
  system
  info

  @@map("notification_type")
}

model Notification {
  id          String           @id @default(uuid()) @db.Uuid
  userId      String           @map("user_id") @db.Uuid
  type        NotificationType
  title       String           @db.VarChar(255)
  message     String?          @db.Text
  relatedId   String?          @map("related_id") @db.Uuid
  isRead      Boolean          @default(false) @map("is_read")
  scheduledAt DateTime?        @map("scheduled_at") @db.Timestamptz
  createdAt   DateTime         @default(now()) @map("created_at") @db.Timestamptz

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([isRead])
  @@index([scheduledAt])
  @@map("notifications")
}

model RefreshToken {
  id         String   @id @default(uuid()) @db.Uuid
  userId     String   @map("user_id") @db.Uuid
  tokenHash  String   @unique @map("token_hash") @db.VarChar(255)
  deviceInfo String?  @map("device_info") @db.VarChar(255)
  expiresAt  DateTime @map("expires_at") @db.Timestamptz
  createdAt  DateTime @default(now()) @map("created_at") @db.Timestamptz

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([expiresAt])
  @@map("refresh_tokens")
}
```

### 5.3 サービス層実装例

```typescript
// services/receipts.service.ts
import { PrismaClient, OcrStatus, Receipt } from '@prisma/client';
import { ocrQueue } from '@/queues/ocr.queue';
import { storageConfig } from '@/config/storage';
import { AppError } from '@/utils/errors';
import path from 'path';
import fs from 'fs/promises';
import { v4 as uuidv4 } from 'uuid';

export class ReceiptsService {
  constructor(private prisma: PrismaClient) {}

  async uploadReceipt(
    userId: string,
    file: Express.Multer.File
  ): Promise<Receipt> {
    // ファイル保存パスの生成
    const date = new Date();
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const fileName = `${uuidv4()}${path.extname(file.originalname)}`;
    const relativePath = `receipts/${year}/${month}/${fileName}`;
    const absolutePath = path.join(storageConfig.uploadDir, relativePath);

    // ディレクトリ作成
    await fs.mkdir(path.dirname(absolutePath), { recursive: true });

    // ファイル保存
    await fs.writeFile(absolutePath, file.buffer);

    // DB登録
    const receipt = await this.prisma.receipt.create({
      data: {
        userId,
        imagePath: relativePath,
        imageSize: file.size,
        mimeType: file.mimetype,
        ocrStatus: OcrStatus.pending,
      },
    });

    // OCRキューに追加
    await ocrQueue.add('process-ocr', {
      receiptId: receipt.id,
      imagePath: absolutePath,
    });

    return receipt;
  }

  async getReceipts(
    userId: string,
    options: {
      page?: number;
      limit?: number;
      status?: OcrStatus;
      startDate?: Date;
      endDate?: Date;
    }
  ) {
    const { page = 1, limit = 20, status, startDate, endDate } = options;
    const skip = (page - 1) * limit;

    const where: any = { userId };

    if (status) {
      where.ocrStatus = status;
    }

    if (startDate || endDate) {
      where.createdAt = {};
      if (startDate) where.createdAt.gte = startDate;
      if (endDate) where.createdAt.lte = endDate;
    }

    const [receipts, total] = await Promise.all([
      this.prisma.receipt.findMany({
        where,
        skip,
        take: limit,
        orderBy: { createdAt: 'desc' },
        include: {
          transaction: {
            select: { id: true, amount: true, transactionDate: true },
          },
        },
      }),
      this.prisma.receipt.count({ where }),
    ]);

    return {
      data: receipts,
      meta: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit),
      },
    };
  }

  async getReceiptById(userId: string, receiptId: string): Promise<Receipt> {
    const receipt = await this.prisma.receipt.findFirst({
      where: { id: receiptId, userId },
      include: {
        transaction: true,
      },
    });

    if (!receipt) {
      throw new AppError('RESOURCE_NOT_FOUND', 'レシートが見つかりません', 404);
    }

    return receipt;
  }

  async updateReceipt(
    userId: string,
    receiptId: string,
    data: {
      extractedMerchant?: string;
      extractedDate?: Date;
      extractedTotal?: number;
    }
  ): Promise<Receipt> {
    const receipt = await this.getReceiptById(userId, receiptId);

    return this.prisma.receipt.update({
      where: { id: receipt.id },
      data: {
        extractedMerchant: data.extractedMerchant,
        extractedDate: data.extractedDate,
        extractedTotal: data.extractedTotal,
      },
    });
  }

  async deleteReceipt(userId: string, receiptId: string): Promise<void> {
    const receipt = await this.getReceiptById(userId, receiptId);

    // ファイル削除
    const absolutePath = path.join(storageConfig.uploadDir, receipt.imagePath);
    await fs.unlink(absolutePath).catch(() => {});

    // DB削除
    await this.prisma.receipt.delete({
      where: { id: receipt.id },
    });
  }

  async retryOcr(userId: string, receiptId: string): Promise<Receipt> {
    const receipt = await this.getReceiptById(userId, receiptId);

    // ステータス更新
    const updated = await this.prisma.receipt.update({
      where: { id: receipt.id },
      data: { ocrStatus: OcrStatus.pending },
    });

    // OCRキューに再追加
    const absolutePath = path.join(storageConfig.uploadDir, receipt.imagePath);
    await ocrQueue.add('process-ocr', {
      receiptId: receipt.id,
      imagePath: absolutePath,
    });

    return updated;
  }

  async confirmReceipt(
    userId: string,
    receiptId: string,
    data: {
      merchant: string;
      amount: number;
      transactionDate: Date;
      type: 'expense' | 'income' | 'adjustment';
      properties?: Record<string, any>;
    }
  ) {
    const receipt = await this.getReceiptById(userId, receiptId);

    // 既にトランザクションが紐づいている場合はエラー
    if (receipt.transaction) {
      throw new AppError(
        'VALIDATION_ERROR',
        'このレシートは既に確定済みです',
        400
      );
    }

    // トランザクション作成
    const transaction = await this.prisma.transaction.create({
      data: {
        userId,
        receiptId: receipt.id,
        type: data.type,
        amount: data.amount,
        transactionDate: data.transactionDate,
        merchant: data.merchant,
        properties: data.properties || {},
      },
    });

    return {
      receipt,
      transaction,
    };
  }
}
```

### 5.4 OCRワーカー実装

```typescript
// workers/ocr.worker.ts
import { Worker, Job } from 'bullmq';
import { createWorker, Worker as TesseractWorker } from 'tesseract.js';
import { PrismaClient, OcrStatus } from '@prisma/client';
import { redisConfig } from '@/config/redis';
import { logger } from '@/utils/logger';

interface OcrJobData {
  receiptId: string;
  imagePath: string;
}

interface ExtractedData {
  merchant: string | null;
  date: Date | null;
  total: number | null;
  rawText: string;
}

class OcrProcessor {
  private tesseractWorker: TesseractWorker | null = null;
  private prisma: PrismaClient;

  constructor() {
    this.prisma = new PrismaClient();
  }

  async initialize(): Promise<void> {
    this.tesseractWorker = await createWorker('jpn+eng', 1, {
      logger: (m) => logger.debug('Tesseract:', m),
    });
  }

  async process(job: Job<OcrJobData>): Promise<void> {
    const { receiptId, imagePath } = job.data;

    logger.info(`Processing OCR for receipt: ${receiptId}`);

    try {
      // ステータスを処理中に更新
      await this.prisma.receipt.update({
        where: { id: receiptId },
        data: { ocrStatus: OcrStatus.processing },
      });

      // OCR実行
      if (!this.tesseractWorker) {
        throw new Error('Tesseract worker not initialized');
      }

      const { data: { text } } = await this.tesseractWorker.recognize(imagePath);

      // テキストから情報抽出
      const extracted = this.extractData(text);

      // 結果をDBに保存
      await this.prisma.receipt.update({
        where: { id: receiptId },
        data: {
          ocrStatus: OcrStatus.success,
          ocrRawText: extracted.rawText,
          extractedMerchant: extracted.merchant,
          extractedDate: extracted.date,
          extractedTotal: extracted.total,
          ocrProcessedAt: new Date(),
        },
      });

      logger.info(`OCR completed for receipt: ${receiptId}`);
    } catch (error) {
      logger.error(`OCR failed for receipt: ${receiptId}`, error);

      await this.prisma.receipt.update({
        where: { id: receiptId },
        data: {
          ocrStatus: OcrStatus.failed,
          ocrProcessedAt: new Date(),
        },
      });

      throw error;
    }
  }

  private extractData(text: string): ExtractedData {
    const lines = text.split('\n').map((l) => l.trim()).filter(Boolean);

    return {
      merchant: this.extractMerchant(lines),
      date: this.extractDate(text),
      total: this.extractTotal(text),
      rawText: text,
    };
  }

  private extractMerchant(lines: string[]): string | null {
    // 最初の有効な行を店名として扱う（簡易実装）
    for (const line of lines) {
      if (line.length >= 2 && line.length <= 50) {
        return line;
      }
    }
    return null;
  }

  private extractDate(text: string): Date | null {
    // 日付パターンの検出
    const patterns = [
      /(\d{4})[\/\-年](\d{1,2})[\/\-月](\d{1,2})/,
      /(\d{2})[\/\-](\d{1,2})[\/\-](\d{1,2})/,
    ];

    for (const pattern of patterns) {
      const match = text.match(pattern);
      if (match) {
        let year = parseInt(match[1]);
        if (year < 100) year += 2000;
        const month = parseInt(match[2]) - 1;
        const day = parseInt(match[3]);

        const date = new Date(year, month, day);
        if (!isNaN(date.getTime())) {
          return date;
        }
      }
    }

    return null;
  }

  private extractTotal(text: string): number | null {
    // 合計金額パターンの検出
    const patterns = [
      /合計[^\d]*(\d{1,3}(?:,\d{3})*|\d+)/,
      /計[^\d]*(\d{1,3}(?:,\d{3})*|\d+)/,
      /TOTAL[^\d]*(\d{1,3}(?:,\d{3})*|\d+)/i,
      /¥\s*(\d{1,3}(?:,\d{3})*|\d+)/,
    ];

    for (const pattern of patterns) {
      const match = text.match(pattern);
      if (match) {
        const amount = parseInt(match[1].replace(/,/g, ''));
        if (!isNaN(amount) && amount > 0) {
          return amount;
        }
      }
    }

    return null;
  }

  async shutdown(): Promise<void> {
    if (this.tesseractWorker) {
      await this.tesseractWorker.terminate();
    }
    await this.prisma.$disconnect();
  }
}

// ワーカー起動
const processor = new OcrProcessor();

const worker = new Worker<OcrJobData>(
  'ocr-queue',
  async (job) => {
    await processor.process(job);
  },
  {
    connection: redisConfig,
    concurrency: 2, // 同時処理数制限
    limiter: {
      max: 5,
      duration: 60000, // 1分間に最大5件
    },
  }
);

processor.initialize().then(() => {
  logger.info('OCR Worker initialized');
});

worker.on('completed', (job) => {
  logger.info(`Job ${job.id} completed`);
});

worker.on('failed', (job, error) => {
  logger.error(`Job ${job?.id} failed:`, error);
});

// Graceful shutdown
process.on('SIGTERM', async () => {
  await worker.close();
  await processor.shutdown();
  process.exit(0);
});
```

---

## 6. インフラ設計

### 6.1 Docker Compose構成

```yaml
# docker-compose.yml
version: '3.8'

services:
  # Nginx Reverse Proxy
  nginx:
    image: nginx:1.25-alpine
    container_name: walleca-nginx
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
      - ./nginx/ssl:/etc/nginx/ssl:ro
      - ./uploads:/var/www/uploads:ro
      - web-build:/var/www/html:ro
    depends_on:
      - api
      - web
    networks:
      - walleca-network
    restart: unless-stopped

  # API Server
  api:
    build:
      context: ./api
      dockerfile: Dockerfile
    container_name: walleca-api
    environment:
      - NODE_ENV=production
      - DATABASE_URL=postgresql://walleca:${DB_PASSWORD}@postgres:5432/walleca
      - REDIS_URL=redis://redis:6379
      - JWT_SECRET=${JWT_SECRET}
      - JWT_REFRESH_SECRET=${JWT_REFRESH_SECRET}
      - UPLOAD_DIR=/app/uploads
    volumes:
      - ./uploads:/app/uploads
    depends_on:
      - postgres
      - redis
    networks:
      - walleca-network
    restart: unless-stopped

  # OCR Worker
  ocr-worker:
    build:
      context: ./api
      dockerfile: Dockerfile.worker
    container_name: walleca-ocr-worker
    environment:
      - NODE_ENV=production
      - DATABASE_URL=postgresql://walleca:${DB_PASSWORD}@postgres:5432/walleca
      - REDIS_URL=redis://redis:6379
    volumes:
      - ./uploads:/app/uploads:ro
    depends_on:
      - postgres
      - redis
    networks:
      - walleca-network
    restart: unless-stopped
    deploy:
      resources:
        limits:
          memory: 2G

  # Notification Worker
  notification-worker:
    build:
      context: ./api
      dockerfile: Dockerfile.notification-worker
    container_name: walleca-notification-worker
    environment:
      - NODE_ENV=production
      - DATABASE_URL=postgresql://walleca:${DB_PASSWORD}@postgres:5432/walleca
      - REDIS_URL=redis://redis:6379
    depends_on:
      - postgres
      - redis
    networks:
      - walleca-network
    restart: unless-stopped

  # React Web (Build Container)
  web:
    build:
      context: ./web
      dockerfile: Dockerfile
    container_name: walleca-web
    volumes:
      - web-build:/app/dist
    networks:
      - walleca-network

  # PostgreSQL
  postgres:
    image: postgres:16-alpine
    container_name: walleca-postgres
    environment:
      - POSTGRES_USER=walleca
      - POSTGRES_PASSWORD=${DB_PASSWORD}
      - POSTGRES_DB=walleca
    volumes:
      - postgres-data:/var/lib/postgresql/data
      - ./init-db:/docker-entrypoint-initdb.d:ro
    networks:
      - walleca-network
    restart: unless-stopped

  # Redis
  redis:
    image: redis:7-alpine
    container_name: walleca-redis
    command: redis-server --appendonly yes
    volumes:
      - redis-data:/data
    networks:
      - walleca-network
    restart: unless-stopped

  # Backup Service
  backup:
    image: postgres:16-alpine
    container_name: walleca-backup
    environment:
      - PGPASSWORD=${DB_PASSWORD}
    volumes:
      - ./backups:/backups
      - ./scripts/backup.sh:/backup.sh:ro
    entrypoint: /bin/sh
    command: -c "chmod +x /backup.sh && crond -f -l 2"
    depends_on:
      - postgres
    networks:
      - walleca-network
    restart: unless-stopped

volumes:
  postgres-data:
  redis-data:
  web-build:

networks:
  walleca-network:
    driver: bridge
```

### 6.2 Nginx設定

```nginx
# nginx/nginx.conf
user nginx;
worker_processes auto;
error_log /var/log/nginx/error.log warn;
pid /var/run/nginx.pid;

events {
    worker_connections 1024;
}

http {
    include /etc/nginx/mime.types;
    default_type application/octet-stream;

    log_format main '$remote_addr - $remote_user [$time_local] "$request" '
                    '$status $body_bytes_sent "$http_referer" '
                    '"$http_user_agent" "$http_x_forwarded_for"';

    access_log /var/log/nginx/access.log main;

    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;
    keepalive_timeout 65;
    types_hash_max_size 2048;

    # Gzip
    gzip on;
    gzip_vary on;
    gzip_proxied any;
    gzip_comp_level 6;
    gzip_types text/plain text/css text/xml application/json application/javascript
               application/xml application/xml+rss text/javascript;

    # Rate Limiting
    limit_req_zone $binary_remote_addr zone=api:10m rate=10r/s;
    limit_req_zone $binary_remote_addr zone=upload:10m rate=1r/s;

    # Upstream
    upstream api_server {
        server api:3000;
        keepalive 32;
    }

    # HTTP -> HTTPS redirect
    server {
        listen 80;
        server_name walleca.local;
        return 301 https://$server_name$request_uri;
    }

    # HTTPS Server
    server {
        listen 443 ssl http2;
        server_name walleca.local;

        # SSL
        ssl_certificate /etc/nginx/ssl/fullchain.pem;
        ssl_certificate_key /etc/nginx/ssl/privkey.pem;
        ssl_session_timeout 1d;
        ssl_session_cache shared:SSL:50m;
        ssl_protocols TLSv1.2 TLSv1.3;
        ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256;
        ssl_prefer_server_ciphers off;

        # Security Headers
        add_header X-Frame-Options "SAMEORIGIN" always;
        add_header X-Content-Type-Options "nosniff" always;
        add_header X-XSS-Protection "1; mode=block" always;
        add_header Referrer-Policy "strict-origin-when-cross-origin" always;

        # Client Body Size (for uploads)
        client_max_body_size 15M;

        # API
        location /v1/ {
            limit_req zone=api burst=20 nodelay;

            proxy_pass http://api_server;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection 'upgrade';
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_cache_bypass $http_upgrade;
        }

        # Upload endpoint (stricter rate limit)
        location /v1/receipts {
            limit_req zone=upload burst=5 nodelay;

            proxy_pass http://api_server;
            proxy_http_version 1.1;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;

            # Upload timeout
            proxy_read_timeout 120s;
            proxy_send_timeout 120s;
        }

        # Uploaded images (authenticated access via API)
        location /uploads/ {
            internal;
            alias /var/www/uploads/;
        }

        # Static files (React SPA)
        location / {
            root /var/www/html;
            index index.html;
            try_files $uri $uri/ /index.html;

            # Cache static assets
            location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2)$ {
                expires 1y;
                add_header Cache-Control "public, immutable";
            }
        }
    }
}
```

### 6.3 Dockerfile

```dockerfile
# api/Dockerfile
FROM node:20-alpine AS builder

WORKDIR /app

COPY package*.json ./
COPY prisma ./prisma/

RUN npm ci

COPY . .

RUN npm run build
RUN npx prisma generate

FROM node:20-alpine AS runner

WORKDIR /app

ENV NODE_ENV=production

RUN addgroup --system --gid 1001 nodejs
RUN adduser --system --uid 1001 walleca

COPY --from=builder /app/node_modules ./node_modules
COPY --from=builder /app/dist ./dist
COPY --from=builder /app/prisma ./prisma
COPY --from=builder /app/package*.json ./

RUN mkdir -p /app/uploads && chown -R walleca:nodejs /app

USER walleca

EXPOSE 3000

CMD ["node", "dist/index.js"]
```

```dockerfile
# api/Dockerfile.worker
FROM node:20-alpine AS builder

WORKDIR /app

COPY package*.json ./
COPY prisma ./prisma/

RUN npm ci

COPY . .

RUN npm run build
RUN npx prisma generate

FROM node:20-alpine AS runner

WORKDIR /app

ENV NODE_ENV=production

# Tesseract OCR のインストール
RUN apk add --no-cache tesseract-ocr tesseract-ocr-data-jpn tesseract-ocr-data-eng

RUN addgroup --system --gid 1001 nodejs
RUN adduser --system --uid 1001 walleca

COPY --from=builder /app/node_modules ./node_modules
COPY --from=builder /app/dist ./dist
COPY --from=builder /app/prisma ./prisma
COPY --from=builder /app/package*.json ./

USER walleca

CMD ["node", "dist/workers/ocr.worker.js"]
```

```dockerfile
# web/Dockerfile
FROM node:20-alpine AS builder

WORKDIR /app

COPY package*.json ./

RUN npm ci

COPY . .

RUN npm run build

FROM alpine:latest AS runner

WORKDIR /app

COPY --from=builder /app/dist ./dist

VOLUME ["/app/dist"]

CMD ["sh", "-c", "cp -r /app/dist/* /output/ 2>/dev/null || true && tail -f /dev/null"]
```

---

## 7. セキュリティ設計

### 7.1 認証フロー

```
┌──────────┐     ┌──────────┐     ┌──────────┐     ┌──────────┐
│  Client  │     │   API    │     │  Redis   │     │ Postgres │
└────┬─────┘     └────┬─────┘     └────┬─────┘     └────┬─────┘
     │                │                │                │
     │ POST /auth/login               │                │
     │ {email, password}              │                │
     │───────────────►│                │                │
     │                │ Find user by email             │
     │                │───────────────────────────────►│
     │                │◄───────────────────────────────│
     │                │                │                │
     │                │ Verify password (bcrypt)       │
     │                │                │                │
     │                │ Generate Access Token (15min)  │
     │                │ Generate Refresh Token (30d)   │
     │                │                │                │
     │                │ Store refresh token hash       │
     │                │───────────────────────────────►│
     │                │                │                │
     │ {accessToken, refreshToken}    │                │
     │◄───────────────│                │                │
     │                │                │                │
     │ Request with Bearer token      │                │
     │───────────────►│                │                │
     │                │ Verify JWT    │                │
     │                │◄──────────────│                │
     │ Response       │                │                │
     │◄───────────────│                │                │
     │                │                │                │
```

### 7.2 パスワード要件

```typescript
// validators/auth.validator.ts
import { z } from 'zod';

export const registerSchema = z.object({
  email: z.string().email('有効なメールアドレスを入力してください'),
  password: z
    .string()
    .min(8, 'パスワードは8文字以上で入力してください')
    .regex(/[A-Z]/, '大文字を1文字以上含めてください')
    .regex(/[a-z]/, '小文字を1文字以上含めてください')
    .regex(/[0-9]/, '数字を1文字以上含めてください'),
  displayName: z
    .string()
    .min(1, '表示名を入力してください')
    .max(100, '表示名は100文字以内で入力してください'),
});
```

### 7.3 画像アクセス制御

```typescript
// routes/receipts.routes.ts
// 画像は直接アクセスではなく、認証付きAPIを経由してアクセス

router.get('/:id/image', authMiddleware, async (req, res) => {
  const receipt = await receiptsService.getReceiptById(
    req.user.id,
    req.params.id
  );

  // X-Accel-Redirect でNginxに内部リダイレクト
  res.set('X-Accel-Redirect', `/uploads/${receipt.imagePath}`);
  res.set('Content-Type', receipt.mimeType);
  res.end();
});
```

---

## 8. テスト設計

### 8.1 テスト構成

```
tests/
├── unit/                           # ユニットテスト
│   ├── services/
│   │   ├── auth.service.test.ts
│   │   ├── receipts.service.test.ts
│   │   └── transactions.service.test.ts
│   └── utils/
│       └── ocr-parser.test.ts
│
├── integration/                    # 統合テスト
│   ├── auth.test.ts
│   ├── receipts.test.ts
│   └── transactions.test.ts
│
└── e2e/                           # E2Eテスト
    ├── auth.e2e.test.ts
    └── receipt-flow.e2e.test.ts
```

### 8.2 テストケース例

```typescript
// tests/integration/receipts.test.ts
import request from 'supertest';
import { app } from '@/app';
import { prisma } from '@/config/database';
import { createTestUser, getAuthToken } from '../helpers';

describe('Receipts API', () => {
  let authToken: string;
  let userId: string;

  beforeAll(async () => {
    const user = await createTestUser();
    userId = user.id;
    authToken = await getAuthToken(user);
  });

  afterAll(async () => {
    await prisma.receipt.deleteMany({ where: { userId } });
    await prisma.user.delete({ where: { id: userId } });
  });

  describe('POST /v1/receipts', () => {
    it('should upload a receipt image', async () => {
      const response = await request(app)
        .post('/v1/receipts')
        .set('Authorization', `Bearer ${authToken}`)
        .attach('image', 'tests/fixtures/receipt.jpg');

      expect(response.status).toBe(201);
      expect(response.body.success).toBe(true);
      expect(response.body.data).toHaveProperty('id');
      expect(response.body.data.ocrStatus).toBe('pending');
    });

    it('should reject files larger than 10MB', async () => {
      const response = await request(app)
        .post('/v1/receipts')
        .set('Authorization', `Bearer ${authToken}`)
        .attach('image', 'tests/fixtures/large-image.jpg');

      expect(response.status).toBe(400);
      expect(response.body.error.code).toBe('FILE_TOO_LARGE');
    });

    it('should reject unauthorized requests', async () => {
      const response = await request(app)
        .post('/v1/receipts')
        .attach('image', 'tests/fixtures/receipt.jpg');

      expect(response.status).toBe(401);
    });
  });

  describe('GET /v1/receipts', () => {
    it('should return paginated receipts', async () => {
      const response = await request(app)
        .get('/v1/receipts')
        .set('Authorization', `Bearer ${authToken}`)
        .query({ page: 1, limit: 10 });

      expect(response.status).toBe(200);
      expect(response.body.success).toBe(true);
      expect(response.body.data).toBeInstanceOf(Array);
      expect(response.body.meta).toHaveProperty('total');
    });
  });
});
```

---

## 9. 開発環境セットアップ

### 9.1 必要なツール

```bash
# Node.js 20 LTS
# Docker & Docker Compose
# Git

# 開発ツール
npm install -g pnpm
```

### 9.2 初期セットアップ手順

```bash
# 1. リポジトリクローン
git clone <repository-url>
cd walleca

# 2. 環境変数設定
cp .env.example .env
# .envを編集してシークレットを設定

# 3. 依存関係インストール
cd api && pnpm install
cd ../web && pnpm install

# 4. Docker起動（DB, Redis）
docker compose up -d postgres redis

# 5. DBマイグレーション
cd api
pnpm prisma migrate dev

# 6. 開発サーバー起動
# ターミナル1: API
cd api && pnpm dev

# ターミナル2: Web
cd web && pnpm dev

# ターミナル3: OCR Worker
cd api && pnpm worker:ocr
```

### 9.3 環境変数一覧

```bash
# .env.example

# Database
DATABASE_URL=postgresql://walleca:password@localhost:5432/walleca
DB_PASSWORD=your_secure_password

# Redis
REDIS_URL=redis://localhost:6379

# JWT
JWT_SECRET=your_jwt_secret_key_min_32_chars
JWT_REFRESH_SECRET=your_refresh_secret_key_min_32_chars

# Storage
UPLOAD_DIR=./uploads
MAX_FILE_SIZE=10485760  # 10MB

# Server
PORT=3000
NODE_ENV=development

# Frontend
VITE_API_BASE_URL=http://localhost:3000/v1
```

---

## 10. 実装優先順位

### Phase 1: 基盤構築（1週目）
1. プロジェクト構造セットアップ
2. Docker Compose環境構築
3. Prismaスキーマ作成・マイグレーション
4. 認証API実装（register, login, refresh, logout）
5. 基本的なエラーハンドリング

### Phase 2: コア機能（2-3週目）
1. レシートアップロードAPI
2. OCRワーカー実装
3. 取引CRUD API
4. サブスクリプションCRUD API

### Phase 3: フロントエンド基盤（4週目）
1. React プロジェクトセットアップ
2. 認証画面（ログイン・登録）
3. レイアウト・ナビゲーション
4. 状態管理（Zustand）セットアップ

### Phase 4: フロントエンド機能（5-6週目）
1. レシート管理画面
2. 取引一覧・詳細画面
3. サブスクリプション管理画面
4. ダッシュボード

### Phase 5: 拡張機能（7週目）
1. ビュー機能（フィルタ・ソート・グループ化）
2. 通知機能
3. 検索機能
4. CSVエクスポート

### Phase 6: 品質向上（8週目）
1. テスト実装
2. パフォーマンス最適化
3. セキュリティレビュー
4. ドキュメント整備

---

## 付録

### A. カテゴリ初期値

```typescript
export const DEFAULT_CATEGORIES = [
  '食費',
  '日用品',
  '交通費',
  '娯楽',
  '通信費',
  '光熱費',
  '医療費',
  '衣服',
  '教育',
  'その他',
];

export const DEFAULT_SUBSCRIPTION_CATEGORIES = [
  '動画配信',
  '音楽配信',
  'クラウドサービス',
  'ゲーム',
  'ニュース・雑誌',
  'フィットネス',
  'ソフトウェア',
  'その他',
];
```

### B. 支払方法初期値

```typescript
export const DEFAULT_PAYMENT_METHODS = [
  '現金',
  'クレジットカード',
  'デビットカード',
  '電子マネー',
  'QRコード決済',
  '銀行振込',
];
```
